# Phoenix Prototype Starter Kit

This repo contains a simple script for cloning a templatized phoenix 1.4 app into a new directory. 

With liveview on it's way I've been prototyping some ideas with drab and texas and I got sick of getting past the boilerplate with all of the tools each time I wanted to start something new. The idea here is to make generating a new project as friction free as possible so I could toss them away with less guilt when I was done trying what I wanted.

The template project preconfigures or includes a few common libraries and combines some samples to make it easier to get up and running. These libraries include:

  * [coherence](https://github.com/smpallen99/coherence) with full options. Currently runs a patched version of coherence that hasn't had it's PR merged back into the main repo yet.
  * [texas](https://gitlab.com/dgmcguire/texas). It integrates the todo list demo from [`https://gitlab.com/dgmcguire/example_texas_app`](https://gitlab.com/dgmcguire/example_texas_app). It functions the same but the styling is not 100% identical to the original.
  * [drab](https://tg.pl/drab). Fully plumbed in and has some boilerplate from the demo, but is commented out as texas is the default. From a freshly cloned project, run `grep -Ri drab lib/ config/ mix.exs` and uncomment the lines to re-enable drab.
  * [quantum](https://github.com/quantum-elixir/quantum-core) for scheduled jobs.
  * [semantic-ui](https://semantic-ui.com), as well as a general layout sample on the dashboard and login sample applied to the coherence login.
  * [distillery](https://github.com/bitwalker/distillery/)
  * [credo](https://github.com/rrrene/credo)
  * [timex](https://github.com/bitwalker/timex)

It is worth noting that drab and texas appear to play well together if you use them on separate content sections. I merely have drab disabled by default to avoid any potential confusion or conflicts if it wasn't necessary.

## Get started

To start a new project

  * run `ruby new_project.rb new_project_name`
  * change into the new directory `cd build/new_project_name`
  * get the dependencies `mix deps.get`
  * create the database `mix do ecto.setup, ecto.migrate`
  * start the server `mix phx.server`

You will also want to run `mix phx.gen.secret` to generate a replacement secret token for the ones configured in dev.exs and prod.secret.exs if you intend to keep that file. In the future I might have the script generate a replacement token during the build process.

## Other options

The usage format of `new_project.rb` is:
`ruby new_project.rb project_name [ModuleBaseName] [--dry-run]`

By default the `ModuleBaseName` is generated by camel casing the `project_name` that is passed as the first argument to `new_project.rb`. You can also directly specify this `ModuleBaseName` by passing the desired base name in a as a camelcased word as the second parameter. This base name is used when naming the project's default and web module namespaces.

An optional `--dry-run` argument can also be passed that will output the intented commands without actually running them. This is useful when you need to see what commands will be run so you can manually run them in a different order or modify them for another purpose. It also doesn't hurt when it comes to debugging new changes. :)


## Using custom template directories

The `new_project.rb` script can also be used to rename existing phoenix projects with some slight modifications.

Simply change the following constants to match the project you are trying to rename. For a standard (non umbrella app) created with `mix phx.new project_name` both constants would be the same:

`TEMPLATE_DIR = "project_name"`
`TEMPLATE_KEY_NAME = "project_name"`

The above assumes you have copied your existing phoenix app into the same directory as `new_project.rb` and `template`. Otherwise you should set `TEMPLATE_DIR` to the path to your existing phoenix app.

These changes will have the effect of treating your existing app as the template and will output a cloned version with the corrected names to the `build` directory when the script is run.
